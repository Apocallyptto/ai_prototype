diff --git a/services/signal_executor.py b/services/signal_executor.py
--- a/services/signal_executor.py
+++ b/services/signal_executor.py
@@ -99,6 +99,9 @@

     symbol_cooldown_seconds: int
     pick_ttl_seconds: int
+
+    trade_only_when_market_open: bool
+    preopen_window_seconds: int

     trading_paused: bool
     dry_run: bool
@@ -129,6 +132,8 @@
         max_daily_loss_usd=_env_float("MAX_DAILY_LOSS_USD", 200.0),
         symbol_cooldown_seconds=_env_int("SYMBOL_COOLDOWN_SECONDS", 60),
         pick_ttl_seconds=_env_int("PICK_TTL_SECONDS", 120),
+        trade_only_when_market_open=_env_bool("TRADE_ONLY_WHEN_MARKET_OPEN", True),
+        preopen_window_seconds=_env_int("PREOPEN_WINDOW_SECONDS", 0),
         trading_paused=_env_bool("TRADING_PAUSED", False),  # kill switch
         dry_run=_env_bool("DRY_RUN", False),
     )
@@ -166,6 +171,41 @@
         raise RuntimeError("Missing ALPACA_API_KEY / ALPACA_API_SECRET")
     return StockHistoricalDataClient(key, sec)

+
+def _market_gate_sleep_seconds(tc: TradingClient, cfg: Cfg) -> Optional[int]:
+    """
+    Market-hours gate using Alpaca clock.
+
+    Returns:
+        - None => ok to trade now
+        - int  => sleep seconds and skip this loop iteration
+    """
+    if not cfg.trade_only_when_market_open:
+        return None
+    try:
+        clock = tc.get_clock()
+    except Exception as e:
+        # fail-open: availability beats perfect gating; other risk guards still apply
+        LOG.warning("market_gate | clock_error=%s | allow_trade", e)
+        return None
+
+    if getattr(clock, "is_open", False):
+        return None
+
+    now = getattr(clock, "timestamp", None)
+    nxt = getattr(clock, "next_open", None)
+    if not now or not nxt:
+        return max(10, int(cfg.poll_seconds))
+
+    secs_to_open = int((nxt - now).total_seconds())
+    pre = int(cfg.preopen_window_seconds or 0)
+    if pre > 0 and secs_to_open <= pre:
+        return None
+
+    remain = max(secs_to_open - pre, 0)
+    # cap sleep so container stays responsive
+    return int(min(max(remain, 10), 300))

 def fetch_new_signals(engine, cfg: Cfg, limit: int = 300) -> List[dict]:
     q = text(
@@ -464,13 +504,13 @@
         "signal_executor starting | MIN_STRENGTH=%.4f | SYMBOLS=%s | PORTFOLIO_ID=%s | POLL=%ss | "
         "ALLOW_SHORT=%s | LONG_ONLY=%s | MAX_NOTIONAL=%.2f | MAX_QTY=%s | MAX_POSITION_QTY=%s | ALLOW_ADD_TO_POSITION=%s | "
         "ALPACA_DEDUPE_MINUTES=%s | CANCEL_OPPOSITE_OPEN_ORDERS=%s | MAX_OPEN_POSITIONS=%s | MAX_OPEN_ORDERS=%s | DAILY_LOSS_STOP_PCT=%.1f | "
-        "MAX_DAILY_LOSS_USD=%.1f | ENABLE_DAILY_RISK_GUARD=%s | SYMBOL_COOLDOWN_SECONDS=%s | PICK_TTL_SECONDS=%s | "
+        "MAX_DAILY_LOSS_USD=%.1f | ENABLE_DAILY_RISK_GUARD=%s | SYMBOL_COOLDOWN_SECONDS=%s | PICK_TTL_SECONDS=%s | TRADE_ONLY_WHEN_MARKET_OPEN=%s | PREOPEN_WINDOW_SECONDS=%s | "
         "TRADING_PAUSED=%s | DRY_RUN=%s",
         cfg.min_strength, cfg.symbols, cfg.portfolio_id, cfg.poll_seconds,
         cfg.allow_short, cfg.long_only, cfg.max_notional, cfg.max_qty, cfg.max_position_qty, cfg.allow_add_to_position,
         cfg.alpaca_dedupe_minutes, cfg.cancel_opposite_open_orders, cfg.max_open_positions, cfg.max_open_orders,
         cfg.daily_loss_stop_pct, cfg.max_daily_loss_usd, cfg.enable_daily_risk_guard,
-        cfg.symbol_cooldown_seconds, cfg.pick_ttl_seconds, cfg.trading_paused, cfg.dry_run
+        cfg.symbol_cooldown_seconds, cfg.pick_ttl_seconds, cfg.trade_only_when_market_open, cfg.preopen_window_seconds, cfg.trading_paused, cfg.dry_run
     )

     while True:
@@ -485,6 +525,20 @@
             if n:
                 LOG.info("auto_unpick | count=%s", n)

+            # Market-hours gate (prevents orders outside regular session; avoids stale-signal backlog)
+            gate_sleep = _market_gate_sleep_seconds(tc, cfg)
+            if gate_sleep is not None:
+                pending = fetch_new_signals(engine, cfg)
+                if pending:
+                    ids = [int(s["id"]) for s in pending]
+                    mark(engine, ids, "skipped", "market_closed")
+                    LOG.info("market_gate | market_closed | skipped=%s | sleep=%ss", len(ids), int(gate_sleep))
+                else:
+                    LOG.info("market_gate | market_closed | skipped=0 | sleep=%ss", int(gate_sleep))
+                time.sleep(int(gate_sleep))
+                continue
+
             signals = fetch_new_signals(engine, cfg)
             LOG.info("fetch_new_signals | fetched %s rows", len(signals))

