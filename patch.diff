diff --git a/services/signal_executor.py b/services/signal_executor.py
--- a/services/signal_executor.py
+++ b/services/signal_executor.py
@@
 class Cfg:
@@
     symbol_cooldown_seconds: int
     pick_ttl_seconds: int

+    trade_only_when_market_open: bool
+    preopen_window_seconds: int
+
     trading_paused: bool
     dry_run: bool
@@
 def load_cfg() -> Cfg:
@@
     return Cfg(
@@
         symbol_cooldown_seconds=_env_int("SYMBOL_COOLDOWN_SECONDS", 60),
         pick_ttl_seconds=_env_int("PICK_TTL_SECONDS", 120),
+        trade_only_when_market_open=_env_bool("TRADE_ONLY_WHEN_MARKET_OPEN", True),
+        preopen_window_seconds=_env_int("PREOPEN_WINDOW_SECONDS", 0),
         trading_paused=_env_bool("TRADING_PAUSED", False),  # kill switch
         dry_run=_env_bool("DRY_RUN", False),
     )
@@
 def make_data_client() -> StockHistoricalDataClient:
     key = os.getenv("ALPACA_API_KEY")
     sec = os.getenv("ALPACA_API_SECRET")
     if not key or not sec:
         raise RuntimeError("Missing ALPACA_API_KEY / ALPACA_API_SECRET")
     return StockHistoricalDataClient(key, sec)

+
+def _market_gate_sleep_seconds(tc: TradingClient, cfg: Cfg) -> Optional[int]:
+    """
+    Market-hours gate using Alpaca clock.
+
+    Returns:
+        - None => ok to trade now
+        - int  => sleep seconds and skip this loop iteration
+    """
+    if not cfg.trade_only_when_market_open:
+        return None
+    try:
+        clock = tc.get_clock()
+    except Exception as e:
+        # fail-closed (safer): if clock not available, don't trade now
+        LOG.warning("market_gate | clock_error=%s | sleep=%ss", e, int(cfg.poll_seconds))
+        return max(10, int(cfg.poll_seconds))
+
+    if getattr(clock, "is_open", False):
+        return None
+
+    now = getattr(clock, "timestamp", None)
+    nxt = getattr(clock, "next_open", None)
+    if not now or not nxt:
+        return max(10, int(cfg.poll_seconds))
+
+    secs_to_open = int((nxt - now).total_seconds())
+    pre = int(cfg.preopen_window_seconds or 0)
+    if pre > 0 and secs_to_open <= pre:
+        return None
+
+    remain = max(secs_to_open - pre, 0)
+    return int(min(max(remain, 10), 300))
+
@@
 def main():
@@
         while True:
             if cfg.trading_paused:
                 time.sleep(cfg.poll_seconds)
                 continue

+            # Market-hours gate (prevents orders outside regular session; avoids stale-signal backlog)
+            gate_sleep = _market_gate_sleep_seconds(tc, cfg)
+            if gate_sleep is not None:
+                pending = fetch_new_signals(engine, cfg)
+                if pending:
+                    ids = [int(s["id"]) for s in pending]
+                    mark(engine, ids, "skipped", "market_closed")
+                    LOG.info("market_gate | market_closed | skipped=%s | sleep=%ss", len(ids), int(gate_sleep))
+                else:
+                    LOG.info("market_gate | market_closed | skipped=0 | sleep=%ss", int(gate_sleep))
+                time.sleep(int(gate_sleep))
+                continue
+
             signals = fetch_new_signals(engine, cfg)
             LOG.info("fetch_new_signals | fetched %s rows", len(signals))
